## 一、Java内存结构

### 1. JVM内存结构

![image-20210905150636105](https://gitee.com/dlutlgy/window_typora/raw/master/images/image-20210905150636105.png)

1. 程序计数器
2. 虚拟机栈
3. 本地方法栈
4. 堆
5. 方法区
6. 运行时常量池
7. 直接内存

+ **程序计数器**

程序计数器属于线程私有的内存，

程序计数器主要有两个作用：

1. 当前线程所执行的字节码的行号指示器，通过改变它实现代码的流程控制，如：顺序执行、选择、循环、异常处理.
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

+ **虚拟机栈**

java虚拟机栈也是线程私有的，其生命周期与线程的相同。Java 虚拟机栈会出现两种错误：`StackOverFlowError` 和 `OutOfMemoryError`。

Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：**局部变量表、操作数栈、动态链接、方法出口**信息。每一次函数调用都会有一个对应的栈帧被压入虚拟机栈，每一个函数调用结束后，都会有一个栈帧被弹出。

局部变量表存放的是编译期可知的Java虚拟机基本数据类型、对象引用、returnAddress类型(指向了一条字节码指令的地址)。

+ **本地方法栈**

虚拟机栈为虚拟机执行 Java 方法服务，本地方法栈则是为虚拟机使用本地方法进行服务。HotSpot虚拟机直接把本地方法栈和虚拟机栈进行了合二为一，也会抛出`StackOverFlowError` 和 `OutOfMemoryError`。

+ **堆**

在内存中占的位置最大，所有线程共享，此内存区域的存放的就是 **对象实例**，但是随着实现角度，并不是所有的对象都存在堆中。

Java 堆可以细分为：新生代（Eden 空间、From Survivor、To Survivor 空间）和老年代、永久代。进一步划分的目的是更好地回收内存，或者更快地分配内存。

通过 -Xms设定程序启动时占用内存大小，通过 -Xmx 设定程序运行期间最大可占用的内存大小。如果程序运行需要占用更多的内存，超出了这个设置值，就会抛出OutOfMemory异常。

+ **方法区**

方法区是**所有线程**共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区逻辑上属于堆的一部分。针对此部分回收目标主要是：**常量池的回收**和**类型的卸载**

1. 永久代

方法区是 JVM 的规范，而永久代（PermGen）是方法区的一种实现方式，并且只有 HotSpot 有永久代。而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有永久代。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出。

2. 元空间

JDK 1.8 的时候，HotSpot 的永久代被彻底移除了，使用元空间替代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。两者最大的区别在于：元空间并不在虚拟机中，而是使用直接内存。

为什么要将永久代替换为元空间呢?

永久代内存受限于 JVM 可用内存，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是相比永久代内存溢出的概率更小。

+ **运行时常量池**

**运行时常量池是方法区的一部分**，在类加载之后，会将编译器生成的各种字面量和符号引号放到运行时常量池。在运行期间动态生成的常量，如 String 类的 intern()方法，也会被放入运行时常量池。

![img](https://gitee.com/dlutlgy/window_typora/raw/master/images/string-new.png)



![img](https://gitee.com/dlutlgy/window_typora/raw/master/images/string-intern.png)



![img](https://gitee.com/dlutlgy/window_typora/raw/master/images/string-equal.png)

+ **直接内存**

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。

NIO的Buffer提供了DirectBuffer，可以直接访问系统物理内存，避免堆内内存到堆外内存的数据拷贝操作，提高效率。DirectBuffer直接分配在物理内存中，并不占用堆空间，其可申请的最大内存受操作系统限制，不受最大堆内存的限制。

直接内存的读写操作比堆内存快，可以提升程序I/O操作的性能。通常在I/O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到直接内存。

### 2. 对象的创建流程

当遇见new 的时候

1. 先检查能否在常量池中定位到类的符号引用，有则说明初始化过，没有进行下一步

2. 为对象分配内存，有两种方式，指针碰撞和空闲列表。具体那种看采用了那种垃圾回收算法。

   （这里引申出一个问题，多线程的时候如何解决内存分配时的并发问题？？见下面）

3. 内存分配完成后，内存空间初始化为0，对象头除外。

4. 设置对象头，这里需要设置这个对象时那个类的实例、如何才能找到类的元信息，对象的哈希码、对象的分代年龄等内容。

5. 在执行class中初始化的方法，进行初始化。



### 3. 如何解决分配内存时的并发问题？

1. 对分配内存空间的动作进行同步处理，实际上采用CAS失败重试的方式保证操作的原子性
2. 给每个线程预先分配小的内存，成为本地内存缓冲（TLAB）本地内存缓冲完了，在新的缓存区时在进行同步锁定。

### 4. 对象的内存布局（未整理）

### 5. Java对象的定位方式

Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针两种：

- 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。 
- 直接指针。reference 中存储的直接就是对象的地址。对象包含到对象类型数据的指针，通过这个指针可以访问对象类型数据。使用直接指针访问方式最大的好处就是访问对象速度快，它节省了一次指针定位的时间开销，虚拟机hotspot主要是使用直接指针来访问对象。

### 6. 堆栈的区别

**物理地址**

堆的物理地址分配对对象是不连续的。在GC的时候需要考虑到不连续的分配，性能较慢。

栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。性能快。

**存放的内容**

堆存放的是对象的实例和数组。

栈存放：局部变量，操作数栈，返回结果。

**程序的可见度**

堆对于整个应用程序都是共享、可见的。

栈只对于线程是可见的，线程私有。

### 7. 什么情况下会发生栈溢出

当线程请求的栈深度超过了虚拟机允许的最大深度时，会抛出StackOverFlowError异常。通过调整参数`-xss`可以调整JVM栈的大小。