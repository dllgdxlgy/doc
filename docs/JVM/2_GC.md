## 二、垃圾收集器

### 1. CMS垃圾收集器

CMS(Consurrent Mark Sweep)收集器：以获取**最短回收停顿时间**为目标的收集器，采用**标记-清除**的算法实现的。

四个过程：

+ 初始标记
+ 并发标记
+ 重新标记
+ 并发清除

其中初始标记和重新标记是STW（stop the world），而并发标记还有并发清楚耗时最长。

过程：

1. 初始标记主要是标记GC Roots能直接关联的对象，速度很快。
2. 并发标记就是从GC Roots上直接关联的对象开始，遍历整个对象图，耗时较长但是不需要进行停顿用户线程。
3. 重新标记是为了修正并发标记时间内，因用户线程继续运作而导致标记产生变动的那一部分标记记录。比并发标记时间短。
4. 并发清除主要是清理删掉标记阶段被判断为死亡的对象。

主要缺点：

+ CMS收集器对处理器的资源非常敏感，(其实所有的收集器对处理器资源都比较敏感),因为：如果处理器少了，在并发阶段，CMS对用户程序的影响就会变得很大。
+ CMS收集器无法处理浮动垃圾，“浮动垃圾”就是在并发标记和并发清除阶段，由用户线程继续运行产生的新的垃圾对象，只能等下次回收。
+ CMS收集器不能等老年代几乎被填满了再去收集，必须留一部分空间供并发阶段使用，可以进行参数设置。
+ 因为CMS是标记-清除的，所以收集结束后会有大量空间碎片产生，这样可能会给大对象直接进入老年代产生影响，这时候就有可能会触发Full GC 。

### 2. G1收集器

G1收集器是**面向全堆**的垃圾收集器

![image-20211115164112865](https://gitee.com/dlutlgy/window_typora/raw/master/images/image-20211115164112865.png)



G1是基于Region的堆内存布局，但是还是遵循分代收集理论的。



#### 要解决的问题

+ Region中存在跨Region引用的对象怎么解决？

使用记忆集来避免对全堆进行扫描，每个Region中都有记忆集，记忆集中都存在着指向自己的指针，也记录了自己指向谁，解决了这个问题，但是带来的缺点就是G1垃圾收集器比其他的垃圾收集器有着更高的内存负担，G1收集器要占用堆容量的10%-20%。

+ 并发阶段如何保证收集线程与用户线程互不干扰的进行？

1. G1垃圾收集器使用的是原始快照的方式来保证用户线程在并发阶段改变对象引用时，不会出现错误。
2. G1 为每一个 Region 区域设计了两个名为 TAMS（Top at Mark Start）的指针， 从 Region 区域划出一部分空间用于记录并发回收过程中的新对象。这样的对象认为它们是存活的，不纳入垃圾回收范围。

+ 怎样建立起可靠的停等预测模型？

G1收集器记录每个Region 的回收耗时，根据Region中记忆集记录的脏卡信息计算要花费的成本，然后确定那些Region回收在不超过期望停顿时间的约束下获得最高的收益。

![image-20211115175101252](https://gitee.com/dlutlgy/window_typora/raw/master/images/image-20211115175101252.png)

#### G1回收过程

1. 初始标记：标记GC Roots能直接关联的对象，并修改 TAMS 的指针。
2. 并发标记：从GC Roots 开始对堆对象进行可达性分析，遍历对象图，找到要回收的对象。然后重新处理SATB记录下的用户线程造成的对象的变动。
3. 最终标记：对用户线程进行短暂的暂停，再来处理并发阶段后仍遗留下来的最后的SATB记录。
4. 筛选回收：负责更新Region的统计数据，对各个Region域的回收价值和成本进行排序，制定回收计划，确定要回收的Region，暂停用户线程，采用的是标记-复制的算法。

#### CMS垃圾收集器与G1收集器对比

CMS采用的是标记-清除算法，而G1整体上采用的是标记-整理算法，局部采用的是标记-复制算法，这说明**G1不会产生内存空间碎片**

G1垃圾收集器的缺点是：**内存占用高**和**程序额外执行负载**要高。