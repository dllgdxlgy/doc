## 运输层

运输层主要是为**两台主机应用进程之间**提供端到端的逻辑通信

### 一、TCP的三次握手过程

![image-20211112192025828](https://gitee.com/dlutlgy/window_typora/raw/master/images/image-20211112192025828.png)

1. 起初、两台主机都是关闭状态、这时候，主机 B 先创建 TCB 模块，从 Closed 状态变为Listen状态。
2. A 进程也是创建传输控制模块TCB，在创建连接时，设置SYN=1，seq=x，seq是初始序号
3. B 收到后，设置SYN=1，ACK=1（建立连接后所有的报文段ACK都设置为1），并同时设置自己的序号y（seq=y）和期待对方发送到序号x+1。
4. 客户端收到后，ACK=1，并设置客户端期望的序列号y+1，并发送自己的序列号x+1

**注**：也是可以改为四报文握手的，而不是四次握手。

### 二、TCP的四次挥手过程

首先，需要确定的是TCP是全双工的，也就是说，客户端A与服务器B能互相发送接受信息。

![image-20211112195257985](https://gitee.com/dlutlgy/window_typora/raw/master/images/image-20211112195257985.png)

1. 客户端设置FIN=1，seq=u，（seq为已传送过的数据序号加一），此时A进入终止等待1（FIN-WAIT-1）
2. B接收到后设置ACK=1，并且ack=u+1（期望对方发送u+1 的报文段）、然后seq=v，是自己的报文段序号，B就进入close-wait状态，这时候，就处于**半关闭**的状态，这时候只是A不能给B发送含有数据的数据报，可是B是可以向A发送的数据的，或许这时候，B向A发送了好多数据。
3. 当 B 发送完，B会发送FIN=1，ACK=1，seq=w（可能向上面所说的又发送了数据，这时候再发送就是w了）ack=u+1，一直期待A能发送u+1，B就进入了Last-ack状态
4. A 收到 B 发送的释放连接的信号，ACK=1，seq=u+1，ack=w+1，此时A就进入了time-wait 状态，这里并没有直接把链接释放掉，需要等待**2MSL**，MSL为最长报文段寿命

### 三、为什么客户端在TIME-WAIT状态必须等待2MSL？

第一，为了保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN＋ACK报文段的确认。B会 时重传这个FIN＋ACK报文段，而A就能在2MSL时间内收到这个重传的FIN＋ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后，A和B都正常进入到 CLOSED状态。如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后 立即释放连接，那么就无法收到B重传的FIN＋ACK 报文段，因而也不会再发送一次 确认报文段。这样，B就无法按照正常步骤进入CLOSED状态。

第二，防止上一节提到的“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间 2 MSL，就可以使本连接持续的时间内所产 生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

### 四、为什么TCP需要三次握手，两次不行？

两次不行，因为：会有一种异常情况，就是客户端 A 发出第一个链接请求的时候，报文段并没有丢失，而是在网络节点中滞留了，这时候A就可能进行超时重传一次链接请求，后来B收到了链接，等数据传输完毕后，就释放了链接，但是这时候在网络节点中滞留的请求重新到达B节点，如果是不进行第三次握手，那么这时候B就认为A已经连接到了B，就会浪费了B的资源。

也就是说：三次握手主要的目的就是确认自己和对方的发送和接受是正常的，如果少了第三次，服务器没办法确认**自己发送正常，对方接受正常**



### 五、TCP和UDP之间的区别

![image-20211112194503909](https://gitee.com/dlutlgy/window_typora/raw/master/images/image-20211112194503909.png)

### 六、TCP的粘包和拆包及解决方案

因为TCP是面向流，没有边界，而操作系统在发送TCP数据时，会通过缓冲区来进行优化，例如缓冲区为1024个字节大小。

如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题。

如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包。

对于粘包和拆包问题，常见的解决方案有四种：

·客户端在发送数据包的时候，每个包都固定长度，比如1024个字节大小，如果客户端发送的数据长度不足1024个字节，则通过补充空格的方式补全到指定长度；

·客户端在每个包的末尾使用固定的分隔符，例如\r\n，如果一个包被拆分了，则等待下一个包发送过来之后找到其中的\r\n，然后对其拆分后的头部部分与前一个包的剩余部分进行合并，这样就得到了一个完整的包；

·将消息分为头部和消息体，在头部中保存有当前整个消息的长度，只有在读取到足够长度的消息之后才算是读到了一个完整的消息；

·通过自定义协议进行粘包和拆包的处理。

### 七、CLOSE-WAIT 与 TIME-WAIT 作用及阶段？

TIME_WAIT 是主动关闭链接时形成的，等待2MSL时间，约4分钟。主要是防止最后一个ACK丢失。 由于TIME_WAIT 的时间会非常长，因此服务端应尽量减少主动关闭连接。

CLOSE_WAIT是被动关闭连接是形成的。根据TCP状态机，服务器端收到客户端发送的FIN，则按照TCP实现发送ACK，因此进入CLOSE_WAIT状态。但如果服务器端不执行close()，就不能由CLOSE_WAIT迁移到LAST_ACK，则系统中会存在很多CLOSE_WAIT状态的连接。此时，可能是系统忙于处理读、写操作，而未将已收到FIN的连接，进行close。此时，recv/read已收到FIN的连接socket，会返回0。

### 八、TCP一共多少种状态？

![image-20211112213306704](https://gitee.com/dlutlgy/window_typora/raw/master/images/image-20211112213306704.png)

1. **CLOSED（关闭状态）**：初始状态，表示TCP连接是“关闭着的”或“未打开的”。
2. **LISTEN（监听状态）** ：表示服务器端的某个SOCKET处于监听状态，可以接受客户端的连接。
3. **SYN_SENT（同步已发送）** ：这个状态与SYN_RCVD 状态相呼应，当客户端SOCKET执行connect()进行连接时，它首先发送SYN报文，然后随即进入到SYN_SENT 状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT 状态表示客户端已发送SYN报文。
4. **SYN_RCVD（同步已收到）** ：表示服务器接收到了来自客户端请求连接的SYN报文。在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat很难看到这种状态，除非故意写一个监测程序，将三次TCP握手过程中最后一个ACK报文不予发送。当TCP连接处于此状态时，再收到客户端的ACK报文，它就会进入到ESTABLISHED 状态。
5. **ESTABLISHED(已建立链接)** ：表示TCP连接已经成功建立。
6. **FIN_WAIT_1（终止等待1）** ：这个状态得好好解释一下，其实FIN_WAIT_1 和FIN_WAIT_2 两种状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET进入到FIN_WAIT_1 状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2 状态。当然在实际的正常情况下，无论对方处于任何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1 状态一般是比较难见到的，而FIN_WAIT_2 状态有时仍可以用netstat看到。
7. **CLOSE_WAIT（关闭等待）** ：表示正在等待关闭。怎么理解呢？当对方close()一个SOCKET后发送FIN报文给自己，你的系统毫无疑问地将会回应一个ACK报文给对方，此时TCP连接则进入到CLOSE_WAIT状态。接下来呢，你需要检查自己是否还有数据要发送给对方，如果没有的话，那你也就可以close()这个SOCKET并发送FIN报文给对方，即关闭自己到对方这个方向的连接。有数据的话则看程序的策略，继续发送或丢弃。简单地说，当你处于CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。
8. **FIN_WAIT_2(终止等待2)** ：上面已经解释了这种状态的由来，实际上FIN_WAIT_2状态下的SOCKET表示半连接，即有一方调用close()主动要求关闭连接。注意：FIN_WAIT_2 是没有超时的（不像TIME_WAIT 状态），这种状态下如果对方不关闭（不配合完成4次挥手过程），那这个 FIN_WAIT_2 状态将一直保持到系统重启，越来越多的FIN_WAIT_2 状态会导致内核crash。
9. **TIME_WAIT（关闭等待）** ：表示收到了对方的FIN报文，并发送出了ACK报文。 TIME_WAIT状态下的TCP连接会等待2*MSL（Max Segment Lifetime，最大分段生存期，指一个TCP报文在Internet上的最长生存时间。每个具体的TCP协议实现都必须选择一个确定的MSL值，RFC 1122建议是2分钟，但BSD传统实现采用了30秒，Linux可以cat /proc/sys/net/ipv4/tcp_fin_timeout看到本机的这个值），然后即可回到CLOSED 可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（这种情况应该就是四次挥手变成三次挥手的那种情况）
10. **CLOSING（）** ：这种状态在实际情况中应该很少见，属于一种比较罕见的例外状态。正常情况下，当一方发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING 状态表示一方发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？那就是当双方几乎在同时close()一个SOCKET的话，就出现了双方同时发送FIN报文的情况，这是就会出现CLOSING 状态，表示双方都正在关闭SOCKET连接。
11. **LAST_ACK（最后确认）** ：当被动关闭的一方在发送FIN报文后，等待对方的ACK报文的时候，就处于LAST_ACK 状态。当收到对方的ACK报文后，也就可以进入到CLOSED 可用状态了。

### 九、TCP拥塞控制和流量控制

#### 拥塞控制

四种算法：慢开始、拥塞避免、快重传、快开始。

**慢开始阶段**：主机一开始发送数据时，不知道网络负荷情况，这时候如果一下子就注入大量数据，就容易导致网络拥塞，最好的方法就是由小到大逐渐增大发送窗口，这时候，每经过一个传输伦次，拥塞窗口就加倍，1、2、4、8、16...

**拥塞避免阶段：**慢开始不能一直增长， 这里还需要设置一个门限值，当小于门限值的时候，使用慢开始的方法，大于门限值的时候，就是用拥塞避免的方法。拥塞避免的方法就是一个一个增加。当网络中出现了超时，发送方判断了网络拥塞，就开始从慢开始继续，此时慢开始门限就变为原来的1/2，

**快重传阶段：**当接连收到三个相同发ACK时，也就是这个报文在网络中丢失，需要快速进行重传，而不是进行慢启动阶段，而是进入快恢复阶段，并且调整门限为原来的1/2。

#### 流量控制

流量控制就是让发送方发送的不要太快，让接受方来得及接收